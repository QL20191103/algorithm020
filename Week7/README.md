学习笔记
括号生成：
 * 思路：
 * 本题的难点就在于对于n对括号可能出现的情况有多少种，然后从里面找出合法的组合
 * 然后对于这种情况，首先应该考虑如何将所有的组合给找出来，再筛选这些组合，或者说
 * 在生成的时候就进行判断。
 * 1。找到所有的组合：
 * 对于n对括号，也就是说，存在2*n个字符，然后每个位置可能出现“（” 或者 “）”，针对这种情况，采用递归的方式
 * 1）在递归函数中首先声明终止条件
 * if(level==2*n) {
 *     System.out.println(s);
 *     return;
 * }
 * 2）处理当前字符串的逻辑：在当前位置添加左括号，或者右括号
 * String s1 = s + "(";
 * String s2 = s + ")";
 * 3）处理下一层，也就是下一个位置的括号；
 * generate(level+1;2*n;s1);
 * generate(level+1;2*n;s2);
 *
 *
 * 通过以上方法，便能将所有的可能找到
 *
 * 然而怎样才能找到合法的组合呢？
 * 在生成括号时，其实满足一个规律：
 * 左括号随便加，但是不能超过括号的对数，也就是n
 * 右括号添加的时候，必须满足，左括号的个数>=右括号的个数
 * 通过这个规律在，以上的条件上进行修改：
 * if(left<n) {
 *     String s1 = s + "(";
 *     generate(left+1,right,n,s1);
 * }
 * if(left>right) {
 *     String s2 = s + ")";
 *     generate(left,right+1,n,s2);
 * }
 * 通过这种方式就能递归的找到所有合法的括号组合了
 
岛屿数量：
 * 思路：
 * 通过该题目的描述可以想到用深度优先遍历的方式解决该问题，
 * 题目说有上下左右连续起来组成的1为一个岛屿，由0代表海水，
 * 那么可以想到，如果遍历这个二维数组时，碰到了1，就将它上
 * 下左右的1全部置为0即可，利用深度优先的方式即可做到
 *
 * 编写递归函数：
 * 1）终止条件：数组出现越界，或者碰到0的时候就终止循环
 * i代表行数，j代表列数
 * if (i>=n||i<0||j>=m||j<0||grid[i][j]=='0'){
 *    return;
 * }
 * 2）中间处理：将该位置的值置为0
 * grid[i][j]='0';
 * 3）向下旋转：去找该位置上下左右的值，是否为1，也就是重复
 * 调用该函数
 * 处理该位置的右边；
 * DFSmarker(grid,i,n,j+1,m);
 * 处理该位置的左边
 * DFSmarker(grid,i,n,j-1,m);
 * 处理该位置的上边
 * DFSmarker(grid,i-1,n,j,m);
 * 处理该位置的下边
 * DFSmarker(grid,i+1,n,j,m);